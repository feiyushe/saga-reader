# Saga Reader 状态管理域技术实现文档

## 概述

状态管理域是 Saga Reader 前端架构的核心中枢，负责统一管理应用中所有关键业务数据的状态，实现组件间数据流的解耦与响应式同步。该域基于 Svelte 的响应式系统构建，采用模块化 Store 设计，通过 TypeScript 类型安全保障数据一致性，为前端展示域提供稳定、高效的数据源。

本域由**核心数据 Store**、**状态工具 Store** 和**类型契约**三部分组成，其中核心数据 Store 承担主要业务逻辑，包括订阅源管理、文章聚合、搜索过滤、阅读状态维护和 AI 对话会话管理。所有 Store 通过事件驱动协作，形成一个完整的前端状态闭环。

## 核心数据 Store 实现

### 1. 核心状态容器 (index.svelte.ts)

`index.svelte.ts` 是整个状态管理域的根容器，负责实例化和聚合所有子 Store，并提供全局状态访问接口。

**核心职责**：
- **实例化子 Store**：创建 `feeds`、`articles`、`reader`、`sprite`、`tasks` 五个核心 Store 实例。
- **状态聚合**：通过 `$state` 定义 `currentFeedId` 和 `currentArticle` 两个全局状态，供 UI 组件直接访问。
- **上下文管理**：提供 `IContext` 接口，封装 `currentArticle` 和 `currentFeedId` 的 getter，作为其他 Store（如 `sprite`）的依赖注入。
- **初始化逻辑**：使用 `$effect` 监听 `feeds` 的刷新，自动加载默认的 `TODAY_FILTER` 订阅源，并在首次启动时触发内容更新。
- **状态计算**：使用 `$derived` 自动计算多个布尔状态（如 `isTodaySelected`、`isFeedSpecified`），减少手动同步逻辑。
- **业务方法**：提供 `setCurrentFeedId`、`setCurrentArticle`、`scheduleUpdate` 等核心业务方法，作为 UI 组件与后端交互的入口。

**关键代码片段**：
```ts
// 实例化所有子 Store
const tasks = createTasks();
const articles = createArticles(tasks); // 依赖 tasks
const feeds = createFeeds();
const reader = createReader({ tasks }); // 依赖 tasks
const sprite = createSprite(context); // 依赖 context

// 全局状态
let currentFeedId: string | undefined = $state(undefined);
let currentArticle: Article | null = $state(null);

// 响应式计算
const isTodaySelected = $derived(currentFeedId === SPECIFY_FEED_IDSET.TODAY_FILTER);
const isFeedSpecified = $derived(isSpecifyFeed(currentFeedId));

// 初始化逻辑
$effect(() => {
  feeds.refresh().then(() => {
    setCurrentFeedId(SPECIFY_FEED_IDSET.TODAY_FILTER).then(() => {
      // 首次启动时自动更新
      if (!has_update_feeds_on_boot) scheduleUpdate();
    });
  });
});
```

### 2. 订阅源管理 (feeds.svelte.ts)

`feeds.svelte.ts` 负责管理用户配置的所有订阅源（RSS/Bing/Baidu）及其分组（FeedPackage）。

**核心职责**：
- **数据模型**：管理 `FeedsPackage[]` 数组，每个包包含多个 `FeedTargetDescription`。
- **状态追踪**：使用 `loadingStore`（来自 `loading.svelte`）追踪 `refresh` 操作的加载、完成和错误状态。
- **CRUD 操作**：封装所有对后端的增删改查请求，包括添加/删除包、添加/删除/重命名订阅源。
- **查询辅助**：提供 `findPackagesOwnerByFeedId` 方法，根据 `feedId` 快速定位其所属的包，是实现 `setCurrentFeedId` 的关键。

**关键代码片段**：
```ts
function create(): StoreType {
  const loadingStore = createLoadingStore(Status.Loading);
  let feedPackages: FeedsPackage[] = $state([]);

  async function refresh() {
    return featuresApi.get_feeds_packages()
      .then((data) => {
        feedPackages = data; // 响应式更新
        loadingStore.complete();
      })
      .catch((e) => loadingStore.error(e));
  }

  // 所有操作都通过 featuresApi 调用后端
  function addFeedsPackage(feedsPackage: FeedsPackage): Promise<void> {
    return featuresApi.add_feeds_package(feedsPackage);
  }

  function findPackagesOwnerByFeedId(feedId: string): FeedsPackage | undefined {
    return feedPackages.find((feedPackage) => 
      feedPackage.feeds.findIndex((feed) => feed.id === feedId) >= 0
    );
  }

  return { loadingStore, feedPackages, refresh, addFeedsPackage, ... };
}
```

### 3. 文章列表与分组 (articles/list/index.svelte.ts)

`articles/list/index.svelte.ts` 是文章聚合的核心，负责从数据库读取文章并按时间分组。

**核心职责**：
- **数据分页**：实现 `PAGING_SIZE = 20` 的分页加载，支持 `loadMore()` 方法进行无限滚动。
- **时间分组**：将从数据库获取的 `ArticleModel[]` 按 `published_at` 字段分组为 `ArticlesGroup[]`，形成“2025-04-05”、“2025-04-04”等时间块。
- **异步加载**：使用 `articles_init_loading` 和 `articles_continous_loading` 两个独立的 LoadingStore，分别追踪初始加载和滚动加载状态。
- **关联更新**：通过 `associatedFeedId` 和 `associatedPackageId` 与 `feeds` 和 `search` Store 关联，当用户切换订阅源或搜索时，自动触发 `refresh()`。
- **任务依赖**：与 `tasks` Store 紧密协作，为 `update_feed_contents` 操作创建唯一 `taskId`，避免重复请求，并在任务完成后自动刷新列表。

**关键代码片段**：
```ts
function create(associations: Associations): StoreType {
  let associatedFeedId = $state(FEED_ID_DEFAULT_FLAT_ON_ROOT);
  let groupedArticles: ArticlesGroup[] = $state([]);

  // 按时间分组
  async function refresh() {
    const data = await featuresApi.read_feed_contents(associatedFeedId, 0, PAGING_SIZE);
    const pending_groupedArticles = [];
    let rolling_published_at = null;
    let rolling_group = null;
    for (const article of data) {
      const published_at = article.published_at;
      if (published_at !== rolling_published_at) {
        rolling_published_at = published_at;
        rolling_group = { name: published_at, articles: [article] };
        pending_groupedArticles.push(rolling_group);
      } else {
        rolling_group?.articles.push(article);
      }
    }
    groupedArticles = pending_groupedArticles;
  }

  // 加载更多
  function loadMore() {
    const offset = groupedArticles.map(ag => ag.articles.length).reduce((a, c) => a + c);
    featuresApi.read_feed_contents(associatedFeedId, offset, PAGING_SIZE).then((data) => {
      // 同样按时间分组追加
    });
  }

  // 与 tasks 交互
  async function updateFeeds() {
    const taskId = generateTaskIdForUpdateFeed(associatedFeedId);
    const pending = tasks.queryPending(taskId);
    if (pending) return pending.promise;
    const promise = featuresApi.update_feed_contents(associatedPackageId, associatedFeedId)
      .then(() => refresh(false))
      .catch((e) => articles_init_loading.error(e));
    tasks.addPending(taskId, promise); // 注册任务
    return promise;
  }
}
```

### 4. 实时搜索过滤 (articles/search/index.svelte.ts)

`articles/search/index.svelte.ts` 实现了基于关键词的实时全文搜索功能。

**核心职责**：
- **双向绑定**：通过 `$state` 定义 `filterText`，与前端 `SearchBar` 组件的输入框进行双向绑定。
- **自动计算**：使用 `$derived` 自动计算 `isFilterActived`，当 `filterText` 非空时返回 `true`，作为 UI 显示搜索结果的依据。
- **轻量级设计**：该 Store 本身不执行搜索，而是通过 `$effect` 监听 `filterText` 的变化，通知 `articles/list` Store 进行数据库查询。

**关键代码片段**：
```ts
function create(): StoreType {
  let filterText = $state('');
  const isFilterActived = $derived(filterText != ''); // 响应式计算

  return {
    get filterText() { return filterText; },
    set filterText(value) { filterText = value; }, // 双向绑定
    get isFilterActived() { return isFilterActived; } // 响应式布尔值
  };
}
```

### 5. 阅读状态管理 (reader.svelte.ts)

`reader.svelte.ts` 负责管理用户对单篇文章的“已读”和“收藏”标记。

**核心职责**：
- **状态更新**：提供 `markAsRead(articleId)` 方法，调用后端 API 更新文章的 `has_read` 状态。
- **内容刷新**：提供 `refreshByEnhancedScraper(articleId, url)` 方法，在用户点击“重新抓取”时，调用后端重新抓取文章内容并更新数据库，然后返回最新文章对象。
- **任务管理**：与 `tasks` Store 集成，为每次刷新操作创建唯一的 `taskId`，避免并发冲突。

**关键代码片段**：
```ts
function create(associates: Associates): StoreType {
  const { tasks } = associates;

  function markAsRead(articleId: number) {
    return featuresApi.mark_as_read(articleId); // 调用后端
  }

  async function refreshByEnhancedScraper(articleId: number, url: string): Promise<Article> {
    const taskId = `Article Updating For ArticleID = ${articleId}`;
    const pending = tasks.queryPending(taskId);
    if (pending) return pending.promise; // 防止重复请求

    const promise = featuresApi.update_article_by_source(articleId, url)
      .then(() => featuresApi.query_by_id(articleId)); // 更新后查询最新数据
    tasks.addPending(taskId, promise); // 注册任务
    return promise;
  }

  return { markAsRead, refreshByEnhancedScraper };
}
```

### 6. AI助手会话管理 (sprite.svelte.ts)

`sprite.svelte.ts` 管理 AI 精灵面板的对话历史和交互状态。

**核心职责**：
- **会话历史**：使用 `$state<ConversationMessage[]>` 存储完整的对话历史，包括用户消息和 AI 回复。
- **交互控制**：提供 `toggle()` 方法控制面板的显示/隐藏，并在隐藏时自动清空历史。
- **异步发送**：`send(input)` 方法是核心，它将用户输入封装为 `ConversationMessage`，追加到历史，然后调用 `featuresApi.chat_with_article_assistant` 与后端 LLM 交互，收到回复后追加到历史。
- **加载状态**：使用 `loading` Store 追踪发送请求的加载、成功和失败状态，UI 组件据此显示加载动画或错误提示。

**关键代码片段**：
```ts
function create(context: IContext): StoreType {
  let history = $state<ConversationMessage[]>([]);
  const loading = createLoadingStore();

  async function send(input: ConversationInput): Promise<boolean> {
    if (loading.status === Status.Loading) return false;

    loading.load();
    try {
      // 添加用户消息
      history.push({ role: "user", mtype: input.mtype, payload: input.payload, created_at: `${Date.now()}` });

      // 调用后端 LLM
      const replyText = await featuresApi.chat_with_article_assistant(
        context.currentArticle?.id, // 传递当前文章上下文
        input.payload,
        history
      );

      // 添加 AI 回复
      history.push({ role: "system", mtype: "text", payload: replyText, created_at: `${Date.now()}` });
      loading.complete();
      return true;
    } catch (e) {
      loading.error(new Error(String(e)));
      return false;
    }
  }

  return { history, loading, toggle, send, isLoading: $derived(loading.status === Status.Loading) };
}
```

### 7. 异步任务管理 (tasks.svelte.ts)

`tasks.svelte.ts` 是一个通用的异步任务管理器，为所有需要追踪后台操作的 Store 提供服务。

**核心职责**：
- **任务追踪**：管理一个 `PendingItem[]` 数组，每个任务包含描述、加载状态和 Promise。
- **状态聚合**：通过 `$derived.by` 计算全局 `pendingStatus` 和 `pendingStatusText`，实时反映所有任务的综合状态（加载中、完成、有错误）。
- **任务创建**：`addPending(description, promise)` 方法创建一个 `PendingItem`，并自动监听 Promise 的成功/失败，更新其 `loadingStore`。
- **任务查询**：`queryPending(description)` 方法允许其他 Store（如 `articles/list`）根据描述查询任务，实现防重复请求。
- **任务清理**：`remove(pending)` 方法用于在任务完成后移除它。

**关键代码片段**：
```ts
function create(): StoreType {
  let pendings: PendingItem[] = $state([]);

  // 全局任务状态聚合
  const pendingStatus: Status = $derived.by(() => {
    let hasError = false;
    for (const pending of pendings) {
      if (pending.loadingStore.status === Status.Loading) return Status.Loading;
      if (pending.loadingStore.status === Status.Error) hasError = true;
    }
    return hasError ? Status.Error : Status.Completed;
  });

  const pendingStatusText = $derived.by(() => {
    switch (pendingStatus) {
      case Status.Loading:
        const loadingPendings = pendings.filter(p => p.loadingStore.status === Status.Loading);
        return `处理中...${loadingPendings.length}项`;
      case Status.Completed:
        return '就绪';
      case Status.Error:
        return '出现错误，点击查看详情';
    }
  });

  function addPending(description: string, promise: Promise<unknown>) {
    const pending = createPending(description, promise);
    pendings.push(pending);
  }

  function queryPending(description: string) {
    return pendings.find(p => p.description === description);
  }

  return { pendingStatus, pendingStatusText, pendings, addPending, queryPending };
}
```

## 状态管理域的交互模式

1.  **UI 组件订阅**：所有 UI 组件（如 `ArticlesList.svelte`）通过 `import { feeds, articles, reader } from '$lib/stores/index'` 订阅 Store 的状态。
2.  **Store 间协作**：Store 之间通过依赖注入进行协作。例如，`articles/list` Store 依赖 `tasks` Store 来管理更新任务，`sprite` Store 依赖 `context` Store 来获取当前文章。
3.  **事件驱动**：状态更新通过 Svelte 的响应式系统自动传播。例如，`filterText` 的变化会触发 `isFilterActived` 的更新，进而触发 `articles/list` 的搜索。
4.  **后端桥接**：所有对后端（Rust）的异步调用都通过 `featuresApi`（`hybrid-apis/feed/impl.ts`）进行，确保了前后端通信的标准化和类型安全。

## 类型契约 (TypeScript Interfaces)

为确保整个前端应用的数据一致性，状态管理域定义了清晰的类型契约：

- **`Article`** (`app/src/lib/types/article.ts`)：定义了文章数据模型，包含 `id`, `title`, `purged_content`, `optimized_content`, `melted_content`, `has_read`, `is_favorite` 等字段。
- **`FeedsPackage` / `FeedTargetDescription`** (`app/src/lib/hybrid-apis/feed/types.ts`)：定义了订阅源及其分组的数据结构。
- **`ConversationMessage`** (`app/src/lib/hybrid-apis/feed/types.ts`)：定义了 AI 对话消息的结构。
- **`LoadingStore`** (`app/src/routes/main/stores/loading.svelte.ts`)：定义了统一的加载状态机（`Status.Loading`, `Status.Completed`, `Status.Error`）。

这些类型不仅在 Store 内部使用，也作为 Store 与 UI 组件、以及 Store 与后端桥接层之间的数据契约，保证了整个系统在类型层面的健壮性。

## 总结

Saga Reader 的状态管理域是一个设计精良、高度模块化的响应式系统。它通过 Svelte 的 `$state` 和 `$derived` 机制，将复杂的业务逻辑（如订阅源管理、文章聚合、AI对话）分解为独立、可复用的 Store。每个 Store 职责单一，通过清晰的依赖关系和事件驱动进行协作，并通过 `featuresApi` 统一与后端通信。这种架构极大地提升了代码的可维护性、可测试性和可扩展性，是构建复杂前端应用的典范。